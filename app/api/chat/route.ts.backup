import { Sandbox } from "@e2b/desktop";
import { ComputerModel, SSEEvent, SSEEventType } from "@/types/api";
import {
  ComputerInteractionStreamerFacade,
  createStreamingResponse,
} from "@/lib/streaming";
import { SANDBOX_TIMEOUT_MS } from "@/lib/config";
import { OpenAIComputerStreamer } from "@/lib/streaming/openai";
import { AnthropicComputerStreamer } from "@/lib/streaming/anthropic";
import { logError, logInfo } from "@/lib/logger";
import { ResolutionScaler } from "@/lib/streaming/resolution";

export const maxDuration = 800;

// Local E2B API helper
async function createLocalSandbox(templateId: string, apiKey: string, baseUrl: string) {
  const response = await fetch(`${baseUrl}/sandboxes`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-API-Key': apiKey,
    },
    body: JSON.stringify({
      templateID: templateId,
      timeout: Math.floor(SANDBOX_TIMEOUT_MS / 1000),
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Failed to create sandbox: ${error}`);
  }

  const data = await response.json();
  return {
    sandboxId: data.sandboxID,
    clientId: data.clientID,
    envdUrl: data.envdURL,
  };
}

class StreamerFactory {
  static getStreamer(
    model: ComputerModel,
    desktop: Sandbox,
    resolution: [number, number]
  ): ComputerInteractionStreamerFacade {
    const resolutionScaler = new ResolutionScaler(desktop, resolution);

    switch (model) {
      case "anthropic":
        return new AnthropicComputerStreamer(desktop, resolutionScaler);
      case "openai":
      default:
        return new OpenAIComputerStreamer(desktop, resolutionScaler);
    }
  }
}

export async function POST(request: Request) {
  const abortController = new AbortController();
  const { signal } = abortController;

  request.signal.addEventListener("abort", () => {
    abortController.abort();
  });

  const {
    messages,
    sandboxId,
    resolution,
    model = "openai",
  } = await request.json();

  const apiKey = process.env.E2B_API_KEY;
  const baseUrl = process.env.E2B_BASE_URL || process.env.E2B_API_URL || 'http://localhost:3000';
  const isLocalInfra = baseUrl.includes('localhost') || baseUrl.includes('127.0.0.1');

  if (!apiKey) {
    return new Response("E2B API key not found", { status: 500 });
  }

  let desktop: Sandbox | undefined;
  let activeSandboxId = sandboxId;
  let vncUrl: string | undefined;

  try {
    if (!activeSandboxId) {
      const templateId = process.env.E2B_DESKTOP_TEMPLATE_ID || 'desktop-vnc';

      if (isLocalInfra) {
        // For local infrastructure, create sandbox directly via API
        // The desktop template already has VNC running, no need for SDK setup
        logInfo("Creating sandbox via local API:", baseUrl);
        const result = await createLocalSandbox(templateId, apiKey, baseUrl);
        activeSandboxId = result.sandboxId;

        // VNC URL for local infrastructure (noVNC on port 6080)
        // Extract sandbox IP from envdURL
        const noVNCHost = process.env.NEXT_PUBLIC_VNC_HOST || '100.64.0.23';

        // Extract IP from envdURL (format: http://10.11.0.X:49983)
        const envdUrl = result.envdUrl || '';
        const ipMatch = envdUrl.match(/http:\/\/([^:]+):/);
        const sandboxIP = ipMatch ? ipMatch[1] : '10.11.0.141';

        logInfo("Extracted sandbox IP:", sandboxIP, "from envdURL:", envdUrl);

        // Use token mode for websockify (matches token config file)
        vncUrl = `http://${noVNCHost}:6080/vnc.html?path=websockify?token=${activeSandboxId}&autoconnect=true`;

        // For local infra, we need to handle desktop operations differently
        // The desktop is already running, we just need the AI interaction
        logInfo("Local sandbox created:", activeSandboxId);

        // Return early with sandbox info - AI operations need different handling for local
        return createStreamingResponse((async function* (): AsyncGenerator<SSEEvent<typeof model>> {
          yield {
            type: SSEEventType.SANDBOX_CREATED,
            sandboxId: activeSandboxId,
            vncUrl: vncUrl as string,
          };
          yield {
            type: SSEEventType.DONE,
            content: "Desktop sandbox created. Note: Local infrastructure mode - AI desktop interaction is limited.",
          };
        })());
      } else {
        // For cloud E2B, use the SDK normally
        const newSandbox = await Sandbox.create(templateId, {
          resolution,
          dpi: 96,
          timeoutMs: SANDBOX_TIMEOUT_MS,
          apiKey: apiKey,
          baseUrl: baseUrl,
        });

        await newSandbox.stream.start();

        activeSandboxId = newSandbox.sandboxId;
        vncUrl = newSandbox.stream.getUrl();
        desktop = newSandbox;
      }
    } else {
      // Connecting to existing sandbox
      if (isLocalInfra) {
        // For local infra, we can't use SDK to connect
        logInfo("Cannot connect to local sandbox via SDK - returning error");
        return new Response(
          JSON.stringify({
            error: "Local infrastructure mode: AI desktop interaction requires cloud E2B",
            sandboxId: activeSandboxId,
          }),
          { status: 501, headers: { 'Content-Type': 'application/json' } }
        );
      } else {
        desktop = await Sandbox.connect(activeSandboxId, {
          apiKey: apiKey,
          baseUrl: baseUrl,
        });
      }
    }

    if (!desktop) {
      return new Response("Failed to connect to sandbox", { status: 500 });
    }

    desktop.setTimeout(SANDBOX_TIMEOUT_MS);

    try {
      const streamer = StreamerFactory.getStreamer(
        model as ComputerModel,
        desktop,
        resolution
      );

      if (!sandboxId && activeSandboxId && vncUrl) {
        async function* stream(): AsyncGenerator<SSEEvent<typeof model>> {
          yield {
            type: SSEEventType.SANDBOX_CREATED,
            sandboxId: activeSandboxId,
            vncUrl: vncUrl as string,
          };

          yield* streamer.stream({ messages, signal });
        }

        return createStreamingResponse(stream());
      } else {
        return createStreamingResponse(streamer.stream({ messages, signal }));
      }
    } catch (error) {
      logError("Error from streaming service:", error);

      return new Response(
        "An error occurred with the AI service. Please try again.",
        { status: 500 }
      );
    }
  } catch (error) {
    logError("Error connecting to sandbox:", error);
    return new Response("Failed to connect to sandbox", { status: 500 });
  }
}
